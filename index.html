<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Projective Texture Mapping</title>
  <script type="text/javascript" src="utils/glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>

  <script id="line-shader-fs" type="x-shader/x-fragment">
    precision highp float;
    uniform vec4 color;
    void main(void) {
      gl_FragColor = color;
    }
  </script>
  <script id="line-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aPosition;
    uniform mat4 uMVMatrix;
    uniform mat4 uProjMatrix;
    void main(void) {
      gl_Position = uProjMatrix * uMVMatrix * vec4(aPosition, 1.0);
    }
  </script>

  <script id="visualize-shader-fs" type="x-shader/x-fragment">
    precision highp float;
    
    // Global quad data
    uniform sampler2D texFieldSampler;
    varying vec2 pass_TextureCoords;

    // Projectors data
    varying vec3 pass_Projector0_Pos;
    varying mat4 pass_Projector0_MVPMatrix;
    uniform sampler2D texProjector0Sampler;

    bool inFrustum(mat4 M, vec3 p) {
        vec4 Pclip = M * vec4(p, 1.);
        return abs(Pclip.x) < Pclip.w && 
               abs(Pclip.y) < Pclip.w && 
               0. < Pclip.z && 
               Pclip.z < Pclip.w;
    }

    void main(void) {
      vec4 quad_texel = texture2D(texFieldSampler, pass_TextureCoords); // Quad region

      // Weights used when blending together pixel colors. If both are 1.0, the resulting pixel will
      // have an equal mixture of their rgba values
      float quad_texel_weight = 1.5;
      float projectors_texels_weight = 1.0;

      if(inFrustum(pass_Projector0_MVPMatrix, pass_Projector0_Pos)) {
        // In-projector 0 region, do a texture lookup
        vec4 Pclip = pass_Projector0_MVPMatrix * vec4(pass_Projector0_Pos, 1.);
        vec2 texture_uv = vec2((Pclip.x + Pclip.w) / (2. * Pclip.w), (Pclip.y + Pclip.w) / (2. * Pclip.w));
        vec4 texel = texture2D(texProjector0Sampler, texture_uv);
        // Now blend this color with the background quad's color       
        gl_FragColor = (projectors_texels_weight * texel + quad_texel_weight * quad_texel) / (quad_texel_weight + projectors_texels_weight); // vec4(1.0, 0.0, 0.0, 1.0);
      } else
        gl_FragColor = quad_texel; // Quad region
    }
  </script>
  <script id="visualize-shader-vs" type="x-shader/x-vertex">
    precision highp float;

    // Global quad data
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoords;

    uniform mat4 uPerspectiveMatrix;
    uniform mat4 uModelViewMatrix;

    varying vec2 pass_TextureCoords;

    // Projectors data
    uniform mat4 uProjector0_PerspectiveMatrix;
    uniform mat4 uProjector0_ModelViewMatrix;
    varying vec3 pass_Projector0_Pos;
    varying mat4 pass_Projector0_MVPMatrix;
    
    void main(void) {
      pass_Projector0_MVPMatrix = uProjector0_PerspectiveMatrix * uProjector0_ModelViewMatrix;
      pass_Projector0_Pos = aVertexPosition;
      // UV coords and position in the quad
      pass_TextureCoords = aTextureCoords;
      gl_Position = uPerspectiveMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
    }
  </script>
  
  <script type="text/javascript">
    var gl; // gl instance
    var fptex_extension;
    var fptextlinear_extension;
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        alert("Could not initialize WebGL");
      }

      fptex_extension = gl.getExtension('OES_texture_float'); // Enable floating point textures
      if (fptex_extension == null) {
        alert("Floating point textures extension not supported");
        return;
      }
      fptextlinear_extension = gl.getExtension('OES_texture_float_linear'); // Enable floating point textures linear filtering
      if (fptextlinear_extension == null) {
        alert("Floating point textures linear filtering extension not supported");
        return;
      }      

      setupGeometries();
      setupShaderPrograms();
      setupTextures();
      //initFramebuffer();
      setupMouseInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      paintLoop();
    }

    var quad_data;
    var quad_indices;

    function setupGeometries() 
    {
      { // Set up a VBO with the field quad data        
        quad_data = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quad_data);
        var vbo_data = [
          3.0, 0.0, -2.0,
          0.0, 0.0,
          -3.0, 0.0, -2.0,
          1.0, 0.0,
          -3.0, 0.0, 2.0,
          1.0, 1.0,
          3.0, 0.0, 2.0,
          0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
        quad_indices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quad_indices);
        var indices = [
          0, 3, 2,
          2, 1, 0
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        quad_indices.count = indices.length;
      }      
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var visualizeProgram;
    var lineProgram;

    // Utility function to get and compile a shader
    function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) { // Check for TEXT_NODE
            str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
        return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }

      return shader;
    }

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "visualize-shader-vs");
      var fragmentShader = getShader(gl, "visualize-shader-fs");
      visualizeProgram = gl.createProgram();
      gl.attachShader(visualizeProgram, vertexShader);
      gl.attachShader(visualizeProgram, fragmentShader);
      gl.linkProgram(visualizeProgram);
      if (!gl.getProgramParameter(visualizeProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(visualizeProgram);
      // Bind uniforms and attributes      
      visualizeProgram.uPerspectiveMatrix = gl.getUniformLocation(visualizeProgram, "uPerspectiveMatrix");
      visualizeProgram.uModelViewMatrix = gl.getUniformLocation(visualizeProgram, "uModelViewMatrix");
      visualizeProgram.texFieldSampler = gl.getUniformLocation(visualizeProgram, "texFieldSampler");
      visualizeProgram.aVertexPosition = gl.getAttribLocation(visualizeProgram, "aVertexPosition");
      gl.enableVertexAttribArray(visualizeProgram.aVertexPosition);
      visualizeProgram.aTextureCoords = gl.getAttribLocation(visualizeProgram, "aTextureCoords");
      gl.enableVertexAttribArray(visualizeProgram.aTextureCoords);
      // Projectors' uniforms and textures
      visualizeProgram.uProjector0_ModelViewMatrix = gl.getUniformLocation(visualizeProgram, "uProjector0_ModelViewMatrix");
      visualizeProgram.uProjector0_PerspectiveMatrix = gl.getUniformLocation(visualizeProgram, "uProjector0_PerspectiveMatrix");
      visualizeProgram.texProjector0Sampler = gl.getUniformLocation(visualizeProgram, "texProjector0Sampler");    

      vertexShader = getShader(gl, "line-shader-vs");
      fragmentShader = getShader(gl, "line-shader-fs");
      lineProgram = gl.createProgram();
      gl.attachShader(lineProgram, vertexShader);
      gl.attachShader(lineProgram, fragmentShader);
      gl.linkProgram(lineProgram);
      if (!gl.getProgramParameter(lineProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(lineProgram);
      // Bind uniforms and attributes
      lineProgram.aPosition = gl.getAttribLocation(lineProgram, "aPosition");
      gl.enableVertexAttribArray(lineProgram.aPosition);   
      lineProgram.uProjMatrix = gl.getUniformLocation(lineProgram, "uProjMatrix");
      lineProgram.uMVMatrix = gl.getUniformLocation(lineProgram, "uMVMatrix");
      lineProgram.color = gl.getUniformLocation(lineProgram, "color"); 
    }

    var fieldTexture;
    var fieldTextureIsSafeToRender = false;

    // First projector's texture
    var centerFieldTexture;
    var centerFieldTextureIsSafeToRender = false;

    function setupTextures() {
      fieldTexture = gl.createTexture();
      fieldTexture.image = new Image();
      fieldTexture.image.onload = function () {
        gl.bindTexture(gl.TEXTURE_2D, fieldTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fieldTexture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
        fieldTextureIsSafeToRender = true;
      }
      fieldTexture.image.src = "assets/testfield.png";

      centerFieldTexture = gl.createTexture();
      centerFieldTexture.image = new Image();
      centerFieldTexture.image.onload = function () {
        gl.bindTexture(gl.TEXTURE_2D, centerFieldTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, centerFieldTexture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
        centerFieldTextureIsSafeToRender = true;
      }
      centerFieldTexture.image.src = "assets/centerfield.png";
    }

    // Projectors matrices and parameters
    function Projector(position, center, up, fovy, aspect, near, far) {
      this.position = position;
      this.center = center; // The point the projector is looking at
      this.up = up;
      this.fovy = fovy;
      this.aspect = aspect;
      this.near = near;
      this.far = far;
      this.modelViewMatrix = mat4.create();
      this.perspectiveMatrix = mat4.create();
      this.recalculate = function() {
        mat4.lookAt(this.position, this.center, this.up, this.modelViewMatrix);
        mat4.perspective(this.fovy, this.aspect, this.near, this.far, this.perspectiveMatrix);
      }
      this.recalculate();
    }
    var projectors = [
      new Projector([2, 3, 3], [0, 0, 0.5], [0, 1, 0], 25, 3/2, 0.1, 50.0)
    ];

    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;
    var sceneRotationMatrix = mat4.create();  

    function setupMouseInput(canvas) {
      mat4.identity(sceneRotationMatrix);
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      var arrow_moves = document.getElementsByClassName("arrow_move");
      for (var i = 0; i < arrow_moves.length; ++i) {
        arrow_moves[i].onmousedown = handleMouseDown;
        arrow_moves[i].onmouseup = handleMouseUp;
        arrow_moves[i].onmousemove = handleMouseMove;
      }
      var arrow_tilts = document.getElementsByClassName("arrow_tilt");
      for (var i = 0; i < arrow_tilts.length; ++i) {
        arrow_tilts[i].onmousedown = handleMouseDown;
        arrow_tilts[i].onmouseup = handleMouseUp;
        arrow_tilts[i].onmousemove = handleMouseMove;
      }
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function degToRad(degrees) {
      return degrees * Math.PI / 180;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = - (newY - lastMouseY);

      if (mouseDownElementId == "canvas") { // Canvas handling        
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
        mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
        mat4.multiply(newRotationMatrix, sceneRotationMatrix, sceneRotationMatrix);
      } else if (mouseDownElementId.indexOf("arrow_move") == 0) { // Projector move handling
        
        var id = parseInt(mouseDownElementId.substring("arrow_move".length, mouseDownElementId.length), 10);

        deltaX *= -0.05;
        deltaY *= 0.05;

        var rightVec = vec3.create([1, 0, 0]);
        var upVec = vec3.create([0, 1, 0]);
        vec3.scale(rightVec, deltaX, rightVec);
        vec3.scale(upVec, deltaY, upVec);

        var pos = vec3.create(projectors[id].position);
        vec3.add(pos, rightVec, pos);
        vec3.add(pos, upVec, pos);

        projectors[id].position = pos;
        projectors[id].recalculate();
      } else if (mouseDownElementId.indexOf("arrow_tilt") == 0) { // Projector tilt handling
        
        var id = parseInt(mouseDownElementId.substring("arrow_tilt".length, mouseDownElementId.length), 10);

        deltaX *= -0.05;
        deltaY *= 0.05;

        // Get vector from eye to center
        var vUp = vec3.create();
        var vRight = vec3.create();
        // Remember that webGL matrices are column-major stored - get the right vector from the transformed MV matrix
        // See http://3dengine.org/Right-up-back_from_modelview
        var vRight = vec3.create([projectors[id].modelViewMatrix[0], 
                                  projectors[id].modelViewMatrix[4], 
                                  projectors[id].modelViewMatrix[8]]);
        var vUp = vec3.create([projectors[id].modelViewMatrix[1], 
                               projectors[id].modelViewMatrix[5], 
                               projectors[id].modelViewMatrix[9]]);

        vec3.normalize(vRight, vRight);
        vec3.normalize(vUp, vUp);
        vec3.scale(vUp, deltaY, vUp);
        vec3.scale(vRight, deltaX, vRight);

        vec3.add(projectors[id].center, vUp, projectors[id].center);
        vec3.add(projectors[id].center, vRight, projectors[id].center);

        projectors[id].recalculate();
      }

      lastMouseX = newX
      lastMouseY = newY;
    }

    function drawProjectorFrustumLines(id, color, modelViewMatrix, perspectiveMatrix) {
      gl.useProgram(lineProgram);
      // MV and Persp matrices must be set to the same as the scene view (that's where the lines are rendered)
      gl.uniformMatrix4fv(lineProgram.uProjMatrix, false /* WebGL supports column-major only */, perspectiveMatrix);
      gl.uniformMatrix4fv(lineProgram.uMVMatrix, false /* WebGL supports column-major only */, modelViewMatrix);
      gl.uniform4fv(lineProgram.color, color);

      // Get vector from eye to center
      var vEye = vec3.create(projectors[id].position);
      var vCenter = vec3.create(projectors[id].center);
      var vDir = vec3.create();
      var vRight = vec3.create();
      // Remember that webGL matrices are column-major stored - get the up vector from the transformed MV matrix
      var vUp = vec3.create([projectors[id].modelViewMatrix[1], 
                             projectors[id].modelViewMatrix[5], 
                             projectors[id].modelViewMatrix[9]]);
      vec3.subtract(vCenter, vEye, vDir);
      vec3.cross(vDir, vUp, vRight);
      vec3.normalize(vDir, vDir);
      vec3.normalize(vUp, vUp);
      vec3.normalize(vRight, vRight);
      var fovy = degToRad(projectors[id].fovy);
      var fovx = Math.atan(projectors[id].aspect * Math.tan(fovy));
      // Get the 4 frustum vectors
      var vUpIncrementZF = vec3.create();
      var vRightIncrementZF = vec3.create();
      // Check out the image at https://i-msdn.sec.s-msft.com/dynimg/IC412711.png to understand this
      vec3.scale(vUp, projectors[id].near * Math.tan(fovy / 2.0), vUpIncrementZF);
      vec3.scale(vRight, projectors[id].near * Math.tan(fovx / 2.0), vRightIncrementZF);
      vec3.scale(vDir, projectors[id].near, vDir);
      var vTopLeft = vec3.create();
      vec3.add(vDir, vUpIncrementZF, vTopLeft);
      vec3.add(vTopLeft, vRightIncrementZF, vTopLeft);
      vec3.normalize(vTopLeft, vTopLeft);
      var vTopRight = vec3.create();
      vec3.add(vDir, vUpIncrementZF, vTopRight);
      vec3.subtract(vTopRight, vRightIncrementZF, vTopRight);
      vec3.normalize(vTopRight, vTopRight);
      var vBottomLeft = vec3.create();
      vec3.subtract(vDir, vUpIncrementZF, vBottomLeft);
      vec3.subtract(vBottomLeft, vRightIncrementZF, vBottomLeft);
      vec3.normalize(vBottomLeft, vBottomLeft);
      var vBottomRight = vec3.create();
      vec3.subtract(vDir, vUpIncrementZF, vBottomRight);
      vec3.add(vBottomRight, vRightIncrementZF, vBottomRight);
      vec3.normalize(vBottomRight, vBottomRight);

      var calculateIntersectionWithPlaneY0 = function(point_in_plane, plane_normal, line_point1, line_point2) {
        var temp1 = vec3.create();
        var temp2 = vec3.create();
        vec3.subtract(point_in_plane, line_point1, temp1);
        vec3.subtract(line_point2, line_point1, temp2);
        var out1, out2;
        out1 = vec3.dot(plane_normal, temp1);
        out2 = vec3.dot(plane_normal, temp2);
        if(out2 == 0)
          return NaN; // Returning NaN means the line is parallel to the plane
        else
          return out1 / out2; // Scale [line_point1->line_point2] by this value to get the to-intersection vector
      };
      var scaleAndAdd = function(vector, othervector, factor) { // Scales othervector by factor and then adds it to vector
        var tmp = vec3.create();
        vec3.scale(othervector, factor, tmp);
        var tmp2 = vec3.create();
        vec3.add(vector, tmp, tmp2);
        return tmp2;
      };

      var vTopLeftEndPoint = vec3.create(projectors[id].position);
      vTopLeftEndPoint = scaleAndAdd(vTopLeftEndPoint, vTopLeft, projectors[id].far);
      var int0 = calculateIntersectionWithPlaneY0(vec3.create([0, 0, 0]), 
                                                  vec3.create([0, 1, 0]), 
                                                  vec3.create(projectors[id].position),
                                                  vTopLeftEndPoint);

      var vTopRightEndPoint = vec3.create(projectors[id].position);
      vTopRightEndPoint = scaleAndAdd(vTopRightEndPoint, vTopRight, projectors[id].far);
      var int1 = calculateIntersectionWithPlaneY0(vec3.create([0, 0, 0]), 
                                                  vec3.create([0, 1, 0]), 
                                                  vec3.create(projectors[id].position),
                                                  vTopRightEndPoint);

      var vBottomLeftEndPoint = vec3.create(projectors[id].position);      
      vBottomLeftEndPoint = scaleAndAdd(vBottomLeftEndPoint, vBottomLeft, projectors[id].far);
      var int2 = calculateIntersectionWithPlaneY0(vec3.create([0, 0, 0]), 
                                                  vec3.create([0, 1, 0]), 
                                                  vec3.create(projectors[id].position),
                                                  vBottomLeftEndPoint);

      var vBottomRightEndPoint = vec3.create(projectors[id].position);
      vBottomRightEndPoint = scaleAndAdd(vBottomRightEndPoint, vBottomRight, projectors[id].far);
      var int3 = calculateIntersectionWithPlaneY0(vec3.create([0, 0, 0]), 
                                                  vec3.create([0, 1, 0]), 
                                                  vec3.create(projectors[id].position),
                                                  vBottomRightEndPoint);
      var transf_pt0 = vec3.create();
      if(int0 == NaN)
        transf_pt0 = vTopLeftEndPoint;
      else { // Not parallel, scale the long to-far-plane vector by the calculated amount
        var start = vec3.create(projectors[id].position);
        var tmp = vec3.create();
        vec3.subtract(vTopLeftEndPoint, start, tmp);
        vec3.scale(tmp, int0, tmp);
        transf_pt0 = start;
        vec3.add(transf_pt0, tmp, transf_pt0);
      }
      var transf_pt1 = vec3.create();
      if(int1 == NaN)
        transf_pt1 = vTopLeftEndPoint;
      else {
        var start = vec3.create(projectors[id].position);
        var tmp = vec3.create();
        vec3.subtract(vTopRightEndPoint, start, tmp);
        vec3.scale(tmp, int1, tmp);
        transf_pt1 = start;
        vec3.add(transf_pt1, tmp, transf_pt1);
      }
      var transf_pt2 = vec3.create();
      if(int2 == NaN)
        transf_pt2 = vTopLeftEndPoint;
      else {
        var start = vec3.create(projectors[id].position);
        var tmp = vec3.create();
        vec3.subtract(vBottomLeftEndPoint, start, tmp);
        vec3.scale(tmp, int2, tmp);
        transf_pt2 = start;
        vec3.add(transf_pt2, tmp, transf_pt2);
      }
      var transf_pt3 = vec3.create();
      if(int3 == NaN)
        transf_pt3 = vTopLeftEndPoint;
      else {
        var start = vec3.create(projectors[id].position);
        var tmp = vec3.create();
        vec3.subtract(vBottomRightEndPoint, start, tmp);
        vec3.scale(tmp, int3, tmp);
        transf_pt3 = start;
        vec3.add(transf_pt3, tmp, transf_pt3);
      }

      var vtx = new Float32Array([
                                  // Start point
                                  projectors[id].position[0],
                                  projectors[id].position[1],
                                  projectors[id].position[2],
                                  // End points
                                  transf_pt0[0], transf_pt0[1], transf_pt0[2],
                                  transf_pt1[0], transf_pt1[1], transf_pt1[2],
                                  transf_pt2[0], transf_pt2[1], transf_pt2[2],
                                  transf_pt3[0], transf_pt3[1], transf_pt3[2]
                                  ]);
      var idx = new Uint16Array([0, 1,
                                 0, 2,
                                 0, 3,
                                 0, 4]);
      vbuf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
      gl.bufferData(gl.ARRAY_BUFFER, vtx, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      ibuf = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibuf);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.lineWidth(3.0);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
      gl.vertexAttribPointer(lineProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibuf);
      gl.drawElements(gl.LINES, 8, gl.UNSIGNED_SHORT, 0);
    }

    function drawScene() {

      if(fieldTextureIsSafeToRender == false || centerFieldTextureIsSafeToRender == false)
        return;

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Set up common uniforms for the quad field
      var perspectiveMatrix = mat4.create();
      var modelViewMatrix = mat4.create();      
      mat4.lookAt([0, 10, -10], [0, 0, 0], [0, 1, 0], modelViewMatrix);
      mat4.multiply(modelViewMatrix, sceneRotationMatrix, modelViewMatrix);
      mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 50.0, perspectiveMatrix);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);      
      gl.useProgram(visualizeProgram);

      // Set up uniforms and texture for the first projector
      gl.uniformMatrix4fv(visualizeProgram.uProjector0_ModelViewMatrix, false /* WebGL supports column-major only */, 
        projectors[0].modelViewMatrix);
      gl.uniformMatrix4fv(visualizeProgram.uProjector0_PerspectiveMatrix, false /* WebGL supports column-major only */, 
        projectors[0].perspectiveMatrix);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, centerFieldTexture);
      gl.uniform1i(visualizeProgram.texProjector0Sampler, 1);

      // Set uniforms for the quad and draw it
      gl.uniformMatrix4fv(visualizeProgram.uPerspectiveMatrix, false /* WebGL supports column-major only */, perspectiveMatrix);
      gl.uniformMatrix4fv(visualizeProgram.uModelViewMatrix, false /* WebGL supports column-major only */, modelViewMatrix);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTexture);
      gl.uniform1i(visualizeProgram.texFieldSampler, 0);
      gl.bindBuffer(gl.ARRAY_BUFFER, quad_data);
      gl.vertexAttribPointer(visualizeProgram.aVertexPosition, 3, gl.FLOAT, false, 5 * 4 /* 5 floats */, 0);
      gl.vertexAttribPointer(visualizeProgram.aTextureCoords, 2, gl.FLOAT, false, 5 * 4 /* 5 floats */, 3 * 4);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quad_indices);
      gl.drawElements(gl.TRIANGLES, quad_indices.count, gl.UNSIGNED_SHORT, 0);

      // Draw projectors extents lines
      var linesColor = [255.0, 255.0, 255.0, 255.0];
      drawProjectorFrustumLines(0, linesColor, modelViewMatrix, perspectiveMatrix);

      // Get projector screen position and, if visible, display arrow controls on it
      var result = [0, 0, 0, 0];
      var mvp = mat4.create();
      //mat4.inverse(modelViewMatrix, mvp);
      mat4.multiply(perspectiveMatrix, modelViewMatrix, mvp);
      mat4.multiplyVec4(mvp, [projectors[0].position[0], projectors[0].position[1], projectors[0].position[2], 1.0], result);
      result[0] /= result[3];
      result[1] /= result[3];

      var screenX = ((result[0] + 1.0) / 2.0) * gl.viewportWidth;
      var screenY = ((1.0 - result[1]) / 2.0) * gl.viewportHeight;

      var arrowElement = document.getElementById("arrow_move0");
      //var arrowStyle = window.getComputedStyle(arrowElement);      
      arrowElement.style.left = screenX - 15 - 20;
      arrowElement.style.top = screenY - 15;
      arrowElement = document.getElementById("arrow_tilt0");
      arrowElement.style.left = screenX - 15 + 20;
      arrowElement.style.top = screenY - 15;
    
      // Cleanup
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }
    
    function paintLoop() {    
      requestAnimFrame(paintLoop);
      drawScene();    
    }

  </script>
  <style>
    #container {
      position: relative;
    }

    div.arrow_move {
      position: absolute;
      width: 30px;
      height: 30px;
      background: url('assets/movearrows.png');
    }
    div.arrow_move:hover {
      background: url('assets/movearrows_hover.png');
    }
    div.arrow_tilt {
      position: absolute;
      width: 30px;
      height: 30px;
      background: url('assets/tiltarrows.png');
    }
    div.arrow_tilt:hover {
      background: url('assets/tiltarrows_hover.png');
    }
  </style>
</head>
<body onload="webGLStart();">
  <div id="container">
    <canvas id="canvas" style="border: none;" width="500" height="500"></canvas>
    <div id="arrow_move0" class="arrow_move"></div>
    <div id="arrow_tilt0" class="arrow_tilt"></div>
  </div>
</body>
</html>